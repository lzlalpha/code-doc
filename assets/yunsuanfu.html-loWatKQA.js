import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o,c as p,d as c,f as n,a as d,w as l,e as a}from"./app-DCgKPjyi.js";const r={},i=a('<h2 id="算术运算符" tabindex="-1"><a class="header-anchor" href="#算术运算符"><span>算术运算符</span></a></h2><table><thead><tr><th>运算符</th><th>功能</th></tr></thead><tbody><tr><td><code>*</code></td><td>乘法</td></tr><tr><td><code>/</code></td><td>除法</td></tr><tr><td><code>%</code></td><td>取模（取余）</td></tr><tr><td><code>+</code></td><td>加法</td></tr><tr><td><code>-</code></td><td>减法</td></tr></tbody></table><p>其中取模运算符 <code>%</code> 意为计算两个整数相除得到的余数，即求余数。</p><p>使用方法：</p><p><code>op=x-y*z</code></p><p>得到的 <code>op</code> 的运算值遵循数学中加减乘除的优先规律，首先进行优先级高的运算，同优先级自左向右运算，括号提高优先级。</p><h3 id="算术运算中的类型转换" tabindex="-1"><a class="header-anchor" href="#算术运算中的类型转换"><span>算术运算中的类型转换</span></a></h3><p>当参与运算的两个变量类型相同时，不发生类型转换，运算结果将会用参与运算的变量的类型容纳，否则会发生类型转换，以使两个变量的类型一致。</p><p>例如，对于一个整型（<code>int</code>）变量 $x$ 和另一个双精度浮点型（<code>double</code>）类型变量 $y$：</p><ul><li><code>x/3</code> 的结果将会是整型；</li><li><code>x/3.0</code> 的结果将会是双精度浮点型；</li><li><code>x/y</code> 的结果将会是双精度浮点型；</li><li><code>x*1/3</code> 的结果将会是整型；</li><li><code>x*1.0/3</code> 的结果将会是双精度浮点型；</li></ul><h2 id="自增-自减-运算符" tabindex="-1"><a class="header-anchor" href="#自增-自减-运算符"><span>自增/自减 运算符</span></a></h2><p>有时我们需要让变量进行增加 1（自增）或者减少 1（自减），这时自增运算符 <code>++</code> 和自减运算符 <code>--</code> 就派上用场了。</p>',12),u=a(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
op1 <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">// op1 = 100，先 op1 = i，然后 i = i + 1</span>
i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
op2 <span class="token operator">=</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>  <span class="token comment">// op2 = 101，先 i = i + 1，然后赋值 op2</span>
i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
op3 <span class="token operator">=</span> i<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// op3 = 100，先赋值 op3，然后 i = i - 1</span>
i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
op4 <span class="token operator">=</span> <span class="token operator">--</span>i<span class="token punctuation">;</span>  <span class="token comment">// op4 = 99，先 i = i - 1，然后赋值 op4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="复合赋值运算符" tabindex="-1"><a class="header-anchor" href="#复合赋值运算符"><span>复合赋值运算符</span></a></h2><p>复合赋值运算符实际上是表达式的缩写形式。可分为复合算术运算符 <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code> 和复合位运算符 <code>&amp;=</code>、<code>|=</code>、<code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>。</p><p>例如，<code>op = op + 2</code> 可写为 <code>op += 2</code>，<code>op = op - 2</code> 可写为 <code>op -= 2</code>，<code>op= op * 2</code> 可写为 <code>op *= 2</code>。</p><h2 id="条件运算符" tabindex="-1"><a class="header-anchor" href="#条件运算符"><span>条件运算符</span></a></h2><p>条件运算符可以看作 <code>if</code> 语句的简写，<code>a ? b : c</code> 中如果表达式 <code>a</code> 成立，那么这个条件表达式的结果是 <code>b</code>，否则条件表达式的结果是 <code>c</code>。</p><h2 id="比较运算符" tabindex="-1"><a class="header-anchor" href="#比较运算符"><span>比较运算符</span></a></h2><table><thead><tr><th>运算符</th><th>功能</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>==</code></td><td>等于</td></tr><tr><td><code>!=</code></td><td>不等于</td></tr></tbody></table><p>其中特别需要注意的是要将等于运算符 <code>==</code> 和赋值运算符 <code>=</code> 区分开来，这在判断语句中尤为重要。</p><p><code>if (op=1)</code> 与 <code>if (op==1)</code> 看起来类似，但实际功能却相差甚远。第一条语句是在对 op 进行赋值，若赋值为非 0 时为真值，表达式的条件始终是满足的，无法达到判断的作用；而第二条语句才是对 <code>op</code> 的值进行判断。</p><h2 id="逻辑运算符" tabindex="-1"><a class="header-anchor" href="#逻辑运算符"><span>逻辑运算符</span></a></h2><table><thead><tr><th>运算符</th><th>功能</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td></tr><tr><td>\`</td><td></td></tr><tr><td><code>!</code></td><td>逻辑非</td></tr></tbody></table><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>Result <span class="token operator">=</span> op1 <span class="token operator">&amp;&amp;</span> op2<span class="token punctuation">;</span>  <span class="token comment">// 当 op1 与 op2 都为真时则 Result 为真</span>
Result <span class="token operator">=</span> op1 <span class="token operator">||</span> op2<span class="token punctuation">;</span>  <span class="token comment">// 当 op1 或 op2 其中一个为真时则 Result 为真</span>
Result <span class="token operator">=</span> <span class="token operator">!</span>op1<span class="token punctuation">;</span>  <span class="token comment">// 当 op1 为假时则 Result 为真</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="逗号运算符" tabindex="-1"><a class="header-anchor" href="#逗号运算符"><span>逗号运算符</span></a></h2><p>逗号运算符可将多个表达式分隔开来，被分隔开的表达式按从左至右的顺序依次计算，整个表达式的值是最后的表达式的值。逗号表达式的优先级在所有运算符中的优先级是 <strong>最低</strong> 的。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>exp1<span class="token punctuation">,</span> exp2<span class="token punctuation">,</span> exp3<span class="token punctuation">;</span>  <span class="token comment">// 最后的值为 exp3 的运算结果。</span>

Result <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token comment">//得到 Result 的值为 3 而不是 11，因为赋值运算符 &quot;=&quot;</span>
<span class="token comment">//的优先级比逗号运算符高，先进行了赋值运算才进行逗号运算。</span>

Result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 若要让 Result 的值得到逗号运算的结果则应将整个表达式用括号提高优先级，此时</span>
<span class="token comment">// Result 的值才为 11。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,16);function m(k,h){const s=t("RouterLink");return o(),p("div",null,[i,c("p",null,[n("自增/自减运算符可放在变量前或变量后面，在变量前称为前缀，在变量后称为后缀，单独使用时前缀后缀无需特别区别，如果需要用到表达式的值则需注意，具体可看下面的例子。详细情况可参考 "),d(s,{to:"/cpp/1jichuyufa/reference.html"},{default:l(()=>[n("引用")]),_:1}),n(" 介绍的例子部分。")]),u])}const x=e(r,[["render",m],["__file","yunsuanfu.html.vue"]]);export{x as default};
